package config

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"

	"github.com/GustavBW/bsc-multiplayer-backend/src/internal"
)

type OutputFormat string

const (
	TS   OutputFormat = "ts"
	JSON OutputFormat = "json"
)

func WriteEventSpecsToFile(file *os.File, outputFormat OutputFormat) error {
	switch outputFormat {
	case TS:
		return writeEventSpecsToTSFile(file)
	case JSON:
		return writeEventSpecsToJSONFile(file)
	default:
		return fmt.Errorf("unsupported output format: %s", outputFormat)
	}

}

func writeEventSpecsToTSFile(file *os.File) error {
	_, writeErr := file.WriteString("// !!! This content is generated by the multiplayer backend tool. Do not modify manually !!!\n\n")
	if writeErr != nil {
		return writeErr
	}
	//TS Types - OriginType enum
	file.WriteString("export enum OriginType {\n")
	file.WriteString("\tServer = \"server\",\n")
	file.WriteString("\tOwner = \"owner\",\n")
	file.WriteString("\tGuest = \"guest\"\n")
	file.WriteString("};\n\n")

	//TS Types - SendPermissions
	file.WriteString("export type SendPermissions = { [key in OriginType]: boolean };\n\n")

	//TS Types - EventSpecification
	file.WriteString("export type EventSpecification = {\n")
	file.WriteString("\tid: number,\n")
	file.WriteString("\tname: string,\n")
	file.WriteString("\tpermissions: SendPermissions,\n")
	file.WriteString("\texpectedMinSize: number\n")
	file.WriteString("};\n\n")

	// Create a slice of the values from the map
	specs := make([]internal.EventSpecification, 0, len(internal.ALL_EVENTS))
	for _, spec := range internal.ALL_EVENTS {
		specs = append(specs, *spec)
	}

	// Sort the slice by the ID field, lowest to highest
	sort.Slice(specs, func(i, j int) bool {
		return specs[i].ID < specs[j].ID
	})

	//Content
	file.WriteString("export const EventSpecifications: EventSpecification[] = [\n")
	for index, spec := range specs {
		file.WriteString("\t{\n")
		file.WriteString(fmt.Sprintf("\t\tid: %d,\n", spec.ID))
		file.WriteString(fmt.Sprintf("\t\tname: \"%s\",\n", spec.Name))
		file.WriteString(fmt.Sprintf("\t\tpermissions: %s,\n", formatTSSendPermissions(spec.SendPermissions)))
		file.WriteString(fmt.Sprintf("\t\texpectedMinSize: %d,\n", spec.ExpectedMinSize))

		if index == len(specs)-1 {
			file.WriteString("\t}\n")
		} else {
			file.WriteString("\t},\n")
		}

	}
	file.WriteString("];\n")
	return nil
}

func formatTSSendPermissions(permissions map[internal.OriginType]bool) string {
	var result = "{"
	count := 0
	total := len(permissions)
	for key, value := range permissions {
		result += fmt.Sprintf("%s: %t", key, value)
		count++
		if count < total {
			result += ", "
		}
	}
	result += "}"
	return result
}

func writeEventSpecsToJSONFile(file *os.File) error {
	return fmt.Errorf("not implemented")
}

func GetOutputFormatFromPath(path string) (OutputFormat, error) {
	switch filepath.Ext(path) {
	case ".ts":
		return TS, nil
	case ".json":
		return JSON, nil
	}

	return "", fmt.Errorf("unsupported file extension: %s", filepath.Ext(path))
}
